#Now we want to implement Genetic Algorithm to solve N-Queens Problem.
#It consists of a conflicts, fitness, population (board condidates), parent_selection, crossover, and mutation
#to define that how quickyl and efficiently find a solution.

#First we add our required libaries.
import time
import tracemalloc
import matplotlib.pyplot as plt
import random
from collections import Counter
from itertools import chain

#Computing the pair of queens conflation to find out which queen threatened by each other.
def conflict_queens(board):
    n = len(board)
    #We changed our methods for finding conflict from N^2 to N by using Counter
    rows = Counter(board)
    diag1 = Counter(i - board[i] for i in range(n))
    diag2 = Counter(i + board[i] for i in range(n))
    conflicts = 0
    for cnt in chain(rows.values(), diag1.values(), diag2.values()):
        conflicts += cnt * (cnt - 1) // 2
    return conflicts

#fitness non-conflicting pairs ==> convert it as a fitness score with computing by max_pairs - conflict
#we return fitness score
def fitness(board):
    n = len(board)
    max_pairs = n * (n-1) // 2
    return max_pairs - conflict_queens(board)

#Initilize a random population , we call it population size
def init_population(N, pop_size):
    #It should be generated by random for returning boards randomly
    #It means we will start from differnt regions for creating our first chessboard with queen
    #Create one empy list for adding our board created randomly
    population = []
    for _ in range(pop_size):
        #one queen per column with placing in the randomized row
        board = [random.randrange(N) for _ in range(N)]
        population.append(board)
    return population

#Select one parent from selection_parent function
def parent_selection(pop, fitnesses, k=3):
#we pick k random individuals and return them with highest fitness score
# pop is our boards list.
#We want to select from these metrics regarding their qualifications for being a parent.
#Integration of fitness and population values
    candidates = random.sample(list(zip(pop, fitnesses)), k=k)
    #By choosing the candidate with maximum fitness score
    parent, _ = max(candidates, key=lambda x:x[1])
    #We need a copy from selected parent to prevent from being modified
    return parent.copy()

#Here is our crossover function to produce on child 
def crossover(parent1, parent2):
    #Combination of 2 parrent at a randomized crossover point
    n = len(parent1)
    #The child gets the first part from parent1 and the second part from parent2
    pt = random.randrange(1, n)
    child = parent1[:pt] + parent2[pt:]
    return child

#Using mutation with probability p_mut
def mutate(board, p_mut):
    #we choose one column and set its row randomly by using the probability of mutation
    if random.random() < p_mut:
        col = random.randrange(len(board))
        board[col] = random.randrange(len(board))
    return board


#Here we are going to search for minimun conflation
#As like as greedy search algortithm to try not to get stuck in local optimia 
#If we want to increase our speed and contorl everything we transfer our O(N^2) to O(N)
def min_conflict_search(board, steps):
    n = len(board)
    for _ in range(steps):
        current_conflict = conflict_queens(board)
        if current_conflict == 0:
            break
        #We count all of columns and rows one time.
        rows = Counter(board)
        diag1 = Counter(i - board[i] for i in range(n))
        diag2 = Counter(i + board[i] for i in range(n))

        #Build conflict list wit O(N) not O(N )
        #We just keep those columns have conflation with another queen
        conflicted_ones = [
            i for i in range(n)
            if rows[board[i]] > 1
            or diag1[i - board[i]] > 1
            or diag2[i + board[i]] > 1
            ]
        if not conflicted_ones:
            continue
        #WE generated random colums and then choosing optimized row for placing our queen
        col = random.choice(conflicted_ones)
        min_conf = float('inf')
        best_row = board[col]
        for row in range(n):
            if row == board[col]:
                continue
            board[col] = row
            check_again = conflict_queens(board)
            if check_again < min_conf:
                min_conf = check_again
                best_row = row
        board[col] = best_row
    return board

        

#Genetic Algorithm Function
#It will be executed by some factors: chessboard size, population size(number of individuals), crossover, mutaiton
#Here we add parameters consist of pop_size, generations, p-crossover, p_mutation, k, elitism, stagnation, local_search_step
#We decided to add elitism which help us to transfer current answer of generation without changing to another generation, It leads not to eliminate the best answer from population
#we add stagnation to restart population
#adding mutation rate : when the population is restared, there is need to increase mutation rate to raise the probability of mutation

def GA_solution(N, pop_size=50, generations=500, p_crossover=0.8, p_mutation=0.1, k=3, elitism=2, stagnation_threshold=200, local_search_steps=50):
    #Generating Boards randomly
    pop = init_population(N, pop_size)
    #Adding new features in algorith to be more scalable and reach the valid answer 
    best_fit = -1
    stagnation = 0
    best_mut = p_mutation
    max_pairs = N * (N-1) // 2
    
    #With setting generations, we want to explore highest fitness score from our population lists
    for gen in range(1, generations +1):
        #calculating fitness
        fitness_score = [fitness(board) for board in pop]
        #put the best score of fitness in max_fitness variable
        current_score = max(fitness_score)
        #making sure there is no conflict to be seen
        #If you do not see any conflicts just return the solution
        if current_score == max_pairs:
            solution = pop[fitness_score.index(current_score)]
            print(f"Solved in generation {gen}")
            return solution
        if current_score > best_fit:
            best_fit = current_score
            stagnation = 0 
            p_mutation = best_mut
        else:
            stagnation += 1
            #We use stagnation for restaring our population
            if stagnation >= stagnation_threshold:
                pop = init_population(N, pop_size)
                stagnation = 0
                #You have to control your p_mutation to not going up drastically.
                p_mutation = min(0.5, best_mut * 1.5)
                print(f"Restart at generation {gen}")
        #Add elitism to go towards top boards, sorting them from highest fit score to lowest ones.
        #Keep how many population you want
        sorted_pop = [b for _, b in sorted(zip(fitness_score, pop), key=lambda x: -x[0])]
        #Creating elitism to move this in next generation
        new_population = sorted_pop[:elitism]
        #Continue till our pop size
        while len(new_population) < pop_size:
            #select our 2 parents
            parent1 = parent_selection(pop, fitness_score)
            parent2 = parent_selection(pop, fitness_score)
            if random.random() < p_crossover:
                #Using crossover to produce the child
                child = crossover(parent1, parent2)

            else:
                #No crossover happen and we just get copy from parent1
                child = parent1.copy()
            #After selecting our parent we will go through mutating and then using min-conflict function to avoid from wrong decisions
            child = mutate(child, p_mutation)
            child = min_conflict_search(child, local_search_steps)
            #We add the resulting child to the next generation
            new_population.append(child)
        #Replace the current population with the new population list
        pop = new_population

    #If loop continues till the end process and we do not find a soltion, we return failure.
    print(f"No solution found after trying {generations} generation")
    return None

def draw_chessboard(board):
    N = len(board)
    # we use figure and axis where we draw square and queens
    #actually axis is contained inside the figure.
    #fig: In chess board will be my whole chessboard image
    #axis : The area you draw
    fig, ax = plt.subplots(figsize=(min(10, N/5), min(10, N/5)))
    # Draw squares
    for row in range(N):
        for col in range(N):
            color = 'white' if (row + col) % 2 == 0 else 'grey'
            #we draw recentagle in row = 0 and it will be started with white
            ax.add_patch(plt.Rectangle((col, N - row - 1), 1, 1, facecolor=color))
    # Draw Queens
            #for drawing fixed queens in our chessboard, we set minimum size and maximum size of our N
            font_size = max(200 // N, 7)
    for row, col in enumerate(board):
        # we flip our chessboard to change the location of row = 0 at the top
        ax.text(col + 0.5, N - row - 1 + 0.5, u"\u265B", fontsize=font_size, ha='center', va='center', color='blue')
    #we set this to see row and column in range of (0, N)
    #from the left edge to the right edge, so we can see all columns 
    #Now all columns are visible
    ax.set_xlim(0, N)
    #from the bottom to the top, so we can see all rows
    #all rows are visible
    ax.set_ylim(0, N)
    #here we remove all marks or numbers on the side of the plot
    ax.set_xticks([])
    ax.set_yticks([])
    #making sure the width and height of each square are equal
    ax.set_aspect('equal')
    #show chessboard
    plt.show()


#Utilizing metrics to see results as well as possible.
def main_execution(N):
    start = time.time()
    tracemalloc.start()
    params = {
    'pop_size':              1200,      
    'generations':           2000,    
    'p_crossover':           0.90,
    'p_mutation':            0.18,
    'k':                     6,       
    'elitism':               6,            
    'stagnation_threshold':  120,      
    'local_search_steps':    10
    }           
    solution = GA_solution(N, **params)
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    end = time.time()
    print(f"N= {N}")
    print(f"We found solution: {'Yes' if solution else 'NO'}")
    print(f"Memory Usage: {peak/1024:.2f} KB")
    print(f"Time reached: {end-start:.4f} s")

    if solution:
        print("Here is our Chessdoard:")
        draw_chessboard(solution)

if __name__ == "__main__":
    allowed_numbers = [10, 30, 50, 100, 200]
    print(f"Please enter the number of queens (N) to solve. Choose one of: {allowed_numbers}")
    while True:
        try:
            N = int(input("Enter the number of queens(N): "))
            if N in allowed_numbers:
                break
            else:
                print("Invalid input. Please select one of:", allowed_numbers)
        except Exception as e:
            print("Invalid input. Please enter a number.")
    main_execution(N)
















